<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Redux | 前端工程师</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Redux应用场景 (多交互，多数据源) 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据  设计思想 web应用是一个状态机，视图与状态是一一对应的。 所有的状态保存在一个对象里面。  1. StoreStore就是保存数据的地方，整个应用只能有一个Store。Redux">
<meta property="og:type" content="article">
<meta property="og:title" content="Redux">
<meta property="og:url" content="https://wanjinqing.github.io/2018/03/05/Redux/index.html">
<meta property="og:site_name" content="前端工程师">
<meta property="og:description" content="Redux应用场景 (多交互，多数据源) 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据  设计思想 web应用是一个状态机，视图与状态是一一对应的。 所有的状态保存在一个对象里面。  1. StoreStore就是保存数据的地方，整个应用只能有一个Store。Redux">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-06T09:01:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redux">
<meta name="twitter:description" content="Redux应用场景 (多交互，多数据源) 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据  设计思想 web应用是一个状态机，视图与状态是一一对应的。 所有的状态保存在一个对象里面。  1. StoreStore就是保存数据的地方，整个应用只能有一个Store。Redux">
  
    <link rel="alternate" href="/atom.xml" title="前端工程师" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer" class="outer">
        <div id="header-title" class="inner">
            <h1 id="logo-wrap">
                <a href="/" id="logo">
                    前端工程师
                </a>
            </h1>
            
                <h2 id="subtitle-wrap">
                    <a href="/" id="subtitle">
                        Knowledge is power.
                    </a>
                </h2>
                
        </div>
        <div id="header-inner" class="inner">
            <nav id="main-nav">
                <a id="main-nav-toggle" class="nav-icon"></a>
                
                    <a class="main-nav-link" href="/">
                        主页
                    </a>
                    
                    <a class="main-nav-link" href="/archives">
                        分类
                    </a>
                    
            </nav>
            <nav id="sub-nav">
                <!-- 
                    <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
                    
                        <a id="nav-search-btn" class="nav-icon" title="搜索"></a> -->
            </nav>
            <div id="search-form-wrap">
                <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wanjinqing.github.io"></form>
            </div>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Redux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/Redux/" class="article-date">
  <time datetime="2018-03-05T08:10:29.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Redux
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Redux应用场景-多交互，多数据源"><a href="#Redux应用场景-多交互，多数据源" class="headerlink" title="Redux应用场景 (多交互，多数据源)"></a>Redux应用场景 (多交互，多数据源)</h3><ol>
<li>用户的使用方式复杂</li>
<li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li>
<li>多个用户之间可以协作</li>
<li>与服务器大量交互，或者使用了WebSocket</li>
<li>View要从多个来源获取数据</li>
</ol>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ol>
<li>web应用是一个状态机，视图与状态是一一对应的。</li>
<li>所有的状态保存在一个对象里面。</li>
</ol>
<h3 id="1-Store"><a href="#1-Store" class="headerlink" title="1. Store"></a>1. Store</h3><p>Store就是保存数据的地方，整个应用只能有一个Store。Redux 提供createStore这个函数，用来生成 Store。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">const store = createStore(fn);</span><br></pre></td></tr></table></figure>
<h3 id="2-State"><a href="#2-State" class="headerlink" title="2. State"></a>2. State</h3><p>Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。<br>当前时刻的 State，可以通过store.getState()拿到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">const store = createStore(fn);</span><br><span class="line">const state = store.getState();</span><br></pre></td></tr></table></figure>
<h3 id="3-Action"><a href="#3-Action" class="headerlink" title="3. Action"></a>3. Action</h3><p>State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。<br>Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const action = &#123;</span><br><span class="line">    type: &apos;ACTION_ONE&apos;,</span><br><span class="line">    other: &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p>
<h3 id="4-store-dispatch"><a href="#4-store-dispatch" class="headerlink" title="4. store.dispatch()"></a>4. store.dispatch()</h3><p>store.dispatch()是 View 发出 Action 的唯一方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">const store = createStore(fn);</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: &apos;ACTION_ONE&apos;,</span><br><span class="line">  other: &apos;Learn Redux&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="5-Reducer"><a href="#5-Reducer" class="headerlink" title="5. Reducer"></a>5. Reducer</h3><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。<br>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">const reducer = function (state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;ACTION_ONE&apos;: </span><br><span class="line">            return state;</span><br><span class="line">        default:</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const store = createStore(reducer);</span><br></pre></td></tr></table></figure>
<p>上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State.</p>
<h3 id="6-store-subscribe"><a href="#6-store-subscribe" class="headerlink" title="6. store.subscribe()"></a>6. store.subscribe()</h3><p>Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">const store = createStore(reducer);</span><br><span class="line">store.subscribe(listener);</span><br></pre></td></tr></table></figure>
<p>只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。<br>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let unsubscribe = store.subscribe(() =&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">);</span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure>
<h3 id="7-工作流程"><a href="#7-工作流程" class="headerlink" title="7. 工作流程"></a>7. 工作流程</h3><p>首先用户触发Action（store.dispatch(action)）,然后Store自动调用了Reducer，并且传入了两个参数，当前的State和Action，Reducer返回新的State。State一旦有变化，Store就会调用监听函数。监听函数通过store.getState()得到当前状态，这时候就可以触发重新渲染View。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 创建reducer</span><br><span class="line">const reducer = (state = 0, action) =&gt; &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;INCREMENT&apos;: return state + 1;</span><br><span class="line">        case &apos;DECREMENT&apos;: return state - 1;</span><br><span class="line">        default: return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// reducer作为参数，创建store</span><br><span class="line">const store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">// 生产一个组件</span><br><span class="line">class Counter extends Component &#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;&#123;this.props.value&#125;&lt;/h1&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.props.onIncrement&#125;&gt;+&lt;/button&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.props.onDecrement&#125;&gt;-&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const render = () =&gt; &#123;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;Counter</span><br><span class="line">            value=&#123;store.getState()&#125;</span><br><span class="line">            onIncrement=&#123;() =&gt; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)&#125;</span><br><span class="line">            onDecrement=&#123;() =&gt; store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;)&#125;</span><br><span class="line">        /&gt;,</span><br><span class="line">        document.getElementById(&apos;root&apos;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化组件</span><br><span class="line">render();</span><br><span class="line"></span><br><span class="line">// 设置监听函数（每当state变化时就会调用render函数，更新组件）</span><br><span class="line">store.subscribe(render);</span><br></pre></td></tr></table></figure>
<h3 id="8-Reducer的拆分"><a href="#8-Reducer的拆分" class="headerlink" title="8. Reducer的拆分"></a>8. Reducer的拆分</h3><p>Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 增加一个reducer</span><br><span class="line">function todos(state = [], action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;ADD_TODO&apos;:</span><br><span class="line">            return state.concat([action.text])</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// reducer修改为</span><br><span class="line">const reducer = combineReducers(&#123;</span><br><span class="line">    todos,</span><br><span class="line">    counter</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Counter组建修改传入属性</span><br><span class="line">value=&#123;store.getState().counter&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="9-中间件"><a href="#9-中间件" class="headerlink" title="9. 中间件"></a>9. 中间件</h3><p>Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware）。</p>
<p>中间件就是一个函数，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let next = store.dispatch;</span><br><span class="line">store.dispatch = function dispatchAndLog(action) &#123;</span><br><span class="line">  console.log(&apos;dispatching&apos;, action);</span><br><span class="line">  next(action);</span><br><span class="line">  console.log(&apos;next state&apos;, store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对store.dispatch进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。</p>
<p>　　中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; applyMiddleware, createStore &#125; from &apos;redux&apos;;</span><br><span class="line">import createLogger from &apos;redux-logger&apos;; // 中间件</span><br><span class="line">const logger = createLogger();</span><br><span class="line"></span><br><span class="line">const store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(logger)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// createStore方法可以接受整个应用的初始状态作为参数，那样的话，applyMiddleware就是第三个参数了。</span><br><span class="line">const store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  initial_state,</span><br><span class="line">  applyMiddleware(logger)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 中间件的次序有讲究</span><br><span class="line">const store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk, promise, logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="10-异步操作"><a href="#10-异步操作" class="headerlink" title="10. 异步操作"></a>10. 异步操作</h3><p>理解了中间件以后，就可以处理异步操作了。<br>同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。</p>
<ul>
<li>操作发起时的 Action</li>
<li>操作成功时的 Action</li>
<li>操作失败时的 Action</li>
</ul>
<p>三种 Action 可以有两种不同的写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 写法一：名称相同，参数不同</span><br><span class="line">&#123; type: &apos;FETCH_POSTS&apos; &#125;</span><br><span class="line">&#123; type: &apos;FETCH_POSTS&apos;, status: &apos;error&apos;, error: &apos;Oops&apos; &#125;</span><br><span class="line">&#123; type: &apos;FETCH_POSTS&apos;, status: &apos;success&apos;, response: &#123; ... &#125; &#125;</span><br><span class="line"></span><br><span class="line">// 写法二：名称不同</span><br><span class="line">&#123; type: &apos;FETCH_POSTS_REQUEST&apos; &#125;</span><br><span class="line">&#123; type: &apos;FETCH_POSTS_FAILURE&apos;, error: &apos;Oops&apos; &#125;</span><br><span class="line">&#123; type: &apos;FETCH_POSTS_SUCCESS&apos;, response: &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let state = &#123;</span><br><span class="line">  // ... </span><br><span class="line">  isFetching: true,</span><br><span class="line">  didInvalidate: true,</span><br><span class="line">  lastUpdated: &apos;xxxxxxx&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，State 的属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间。</p>
<ul>
<li>操作开始时，送出一个 Action，触发 State 更新为”正在操作”状态，View 重新渲染</li>
<li>操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染</li>
</ul>
<h3 id="11-redux-thunk-中间件"><a href="#11-redux-thunk-中间件" class="headerlink" title="11. redux-thunk 中间件"></a>11. redux-thunk 中间件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const fetchPosts = function (postTitle) &#123;</span><br><span class="line">    return function (dispatch, getState) &#123;</span><br><span class="line">        dispatch(requestPosts(postTitle));</span><br><span class="line">        return fetch(`/some/API/$&#123;postTitle&#125;.json`)</span><br><span class="line">            .then(response =&gt; response.json())</span><br><span class="line">            .then(json =&gt; dispatch(receivePosts(postTitle, json)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用方法一</span><br><span class="line">store.dispatch(fetchPosts(&apos;reactjs&apos;));</span><br><span class="line">// 使用方法二</span><br><span class="line">store.dispatch(fetchPosts(&apos;reactjs&apos;)).then(() =&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码中，fetchPosts是一个Action Creator（动作生成器），返回一个函数。这个函数执行后，先发出一个Action（requestPosts(postTitle)），然后进行异步操作。拿到结果后，先将结果转成 JSON 格式，然后再发出一个 Action（ receivePosts(postTitle, json)）。</p>
<p>上面代码中，有几个地方需要注意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象。</span><br><span class="line">（2）返回的函数的参数是dispatch和getState这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容。</span><br><span class="line">（3）在返回的函数之中，先发出一个 Action（requestPosts(postTitle)），表示操作开始。</span><br><span class="line">（4）异步操作结束之后，再发出一个 Action（receivePosts(postTitle, json)），表示操作结束。</span><br></pre></td></tr></table></figure></p>
<p>这样的处理，就解决了自动发送第二个 Action 的问题。但是，又带来了一个新的问题，Action 是由store.dispatch方法发送的。而store.dispatch方法正常情况下，参数只能是对象，不能是函数。<br>这时，就要使用中间件redux-thunk。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;;</span><br><span class="line">import reducer from &apos;./reducers&apos;;</span><br><span class="line"></span><br><span class="line">// Note: this API requires redux@&gt;=3.1.0</span><br><span class="line">const store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。<br>因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch。</p>
<h3 id="12-redux-promise-中间件"><a href="#12-redux-promise-中间件" class="headerlink" title="12. redux-promise 中间件"></a>12. redux-promise 中间件</h3><p>既然 Action Creator 可以返回函数，当然也可以返回其他值。另一种异步操作的解决方案，就是让 Action Creator 返回一个 Promise 对象。<br>这就需要使用redux-promise中间件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import promiseMiddleware from &apos;redux-promise&apos;;</span><br><span class="line">import reducer from &apos;./reducers&apos;;</span><br><span class="line"></span><br><span class="line">const store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(promiseMiddleware)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这个中间件使得store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。<br>写法一，返回值是一个 Promise 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fetchPosts = </span><br><span class="line">  (dispatch, postTitle) =&gt; new Promise(function (resolve, reject) &#123;</span><br><span class="line">     dispatch(requestPosts(postTitle));</span><br><span class="line">     return fetch(`/some/API/$&#123;postTitle&#125;.json`)</span><br><span class="line">       .then(response =&gt; &#123;</span><br><span class="line">         type: &apos;FETCH_POSTS&apos;,</span><br><span class="line">         payload: response.json()</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>写法二，Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法，并且写法也要变成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createAction &#125; from &apos;redux-actions&apos;;</span><br><span class="line"></span><br><span class="line">class AsyncApp extends Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    const &#123; dispatch, selectedPost &#125; = this.props</span><br><span class="line">    // 发出同步 Action</span><br><span class="line">    dispatch(requestPosts(selectedPost));</span><br><span class="line">    // 发出异步 Action</span><br><span class="line">    dispatch(createAction(</span><br><span class="line">      &apos;FETCH_POSTS&apos;</span><br><span class="line">      , </span><br><span class="line">      fetch(`/some/API/$&#123;postTitle&#125;.json`)</span><br><span class="line">        .then(response =&gt; response.json())</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，第二个dispatch方法发出的是异步 Action，只有等到操作结束，这个 Action 才会实际发出。注意，createAction的第二个参数必须是一个 Promise 对象。</p>
<h3 id="13-react-redux"><a href="#13-react-redux" class="headerlink" title="13. react-redux"></a>13. react-redux</h3><p>这个库是可以选用的。实际项目中，你应该权衡一下，是直接使用 Redux，还是使用 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">React-Redux</a>。<br>后者虽然提供了便利，但是需要掌握额外的 API，并且要遵守它的组件拆分规范。</p>
<h5 id="13-1-UI组件"><a href="#13-1-UI组件" class="headerlink" title="13.1 UI组件"></a>13.1 UI组件</h5><p>React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。</p>
<ul>
<li>只负责 UI 的呈现，不带有任何业务逻辑</li>
<li>没有状态（即不使用this.state这个变量）</li>
<li>所有数据都由参数（this.props）提供</li>
<li>不使用任何 Redux 的 API</li>
</ul>
<h5 id="13-2-容器组件"><a href="#13-2-容器组件" class="headerlink" title="13.2 容器组件"></a>13.2 容器组件</h5><ul>
<li>负责管理数据和业务逻辑，不负责 UI 的呈现</li>
<li>带有内部状态</li>
<li>使用 Redux 的 API</li>
</ul>
<p>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p>
<h5 id="13-3-connect"><a href="#13-3-connect" class="headerlink" title="13.3 connect"></a>13.3 connect</h5><p>React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;</span><br><span class="line">const VisibleTodoList = connect()(TodoList);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件。<br>但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。<br>（1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数<br>（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。</p>
<p>因此，connect方法的完整 API 如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;</span><br><span class="line"></span><br><span class="line">const VisibleTodoList = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure>
<p>上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<h5 id="13-4-mapStateToProps"><a href="#13-4-mapStateToProps" class="headerlink" title="13.4 mapStateToProps()"></a>13.4 mapStateToProps()</h5><p>mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。<br>作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    todos: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const getVisibleTodos = (todos, filter) =&gt; &#123;</span><br><span class="line">  switch (filter) &#123;</span><br><span class="line">    case &apos;SHOW_ALL&apos;:</span><br><span class="line">      return todos</span><br><span class="line">    case &apos;SHOW_COMPLETED&apos;:</span><br><span class="line">      return todos.filter(t =&gt; t.completed)</span><br><span class="line">    case &apos;SHOW_ACTIVE&apos;:</span><br><span class="line">      return todos.filter(t =&gt; !t.completed)</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(&apos;Unknown filter: &apos; + filter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>
<p>mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。</p>
<p>connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。</p>
<h5 id="13-5-mapDispatchToProps"><a href="#13-5-mapDispatchToProps" class="headerlink" title="13.5 mapDispatchToProps()"></a>13.5 mapDispatchToProps()</h5><p>mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。<br>也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p>
<p>如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = (</span><br><span class="line">  dispatch,</span><br><span class="line">  ownProps</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    onClick: () =&gt; &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: &apos;SET_VISIBILITY_FILTER&apos;,</span><br><span class="line">        filter: ownProps.filter</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。<br>如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line">  onClick: (filter) =&gt; &#123;</span><br><span class="line">    type: &apos;SET_VISIBILITY_FILTER&apos;,</span><br><span class="line">    filter: filter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="13-6-lt-Provider-组件"><a href="#13-6-lt-Provider-组件" class="headerlink" title="13.6 &lt;Provider> 组件"></a>13.6 &lt;Provider> 组件</h5><p>connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。<br>一种解决方法是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦。<br>React-Redux 提供Provider组件，可以让容器组件拿到state。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;</span><br><span class="line">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class="line">import todoApp from &apos;./reducers&apos;</span><br><span class="line">import App from &apos;./components/App&apos;</span><br><span class="line"></span><br><span class="line">let store = createStore(todoApp);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。</p>
<p>它的原理是React组件的context属性，请看源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Provider extends Component &#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      store: this.props.store</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store: React.PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，store放在了上下文对象context上面。然后，子组件就可以从context拿到store，代码大致如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class VisibleTodoList extends Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    const &#123; store &#125; = this.context;</span><br><span class="line">    this.unsubscribe = store.subscribe(() =&gt;</span><br><span class="line">      this.forceUpdate()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const props = this.props;</span><br><span class="line">    const &#123; store &#125; = this.context;</span><br><span class="line">    const state = store.getState();</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VisibleTodoList.contextTypes = &#123;</span><br><span class="line">  store: React.PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="13-7-实例"><a href="#13-7-实例" class="headerlink" title="13.7 实例"></a>13.7 实例</h5><p>UI组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Counter extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; value, onIncreaseClick &#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;value&#125;&lt;/span&gt;</span><br><span class="line">        &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，这个 UI 组件有两个参数：value和onIncreaseClick。前者需要从state计算得到，后者需要向外发出 Action。<br>接着，定义value到state的映射，以及onIncreaseClick到dispatch的映射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function mapStateToProps(state) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    value: state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function mapDispatchToProps(dispatch) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    onIncreaseClick: () =&gt; dispatch(increaseAction)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Action Creator</span><br><span class="line">const increaseAction = &#123; type: &apos;increase&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，使用connect方法生成容器组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const App = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Counter)</span><br></pre></td></tr></table></figure>
<p>然后，定义这个组件的 Reducer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Reducer</span><br><span class="line">function counter(state = &#123; count: 0 &#125;, action) &#123;</span><br><span class="line">  const count = state.count</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &apos;increase&apos;:</span><br><span class="line">      return &#123; count: count + 1 &#125;</span><br><span class="line">    default:</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，生成store对象，并使用Provider在根组件外面包一层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; loadState, saveState &#125; from &apos;./localStorage&apos;;</span><br><span class="line"></span><br><span class="line">const persistedState = loadState();</span><br><span class="line">const store = createStore(</span><br><span class="line">  todoApp,</span><br><span class="line">  persistedState</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.subscribe(throttle(() =&gt; &#123;</span><br><span class="line">  saveState(&#123;</span><br><span class="line">    todos: store.getState().todos,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 1000))</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>完整的代码看这里<br><a href="https://github.com/wanjinqing/redux" target="_blank" rel="noopener">https://github.com/wanjinqing/redux</a></p>
<p>使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层，毕竟Provider的唯一功能就是传入store对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const Root = (&#123; store &#125;) =&gt; (</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;Route path=&quot;/&quot; component=&#123;App&#125; /&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wanjinqing.github.io/2018/03/05/Redux/" data-id="cjeffnndd0002bgvpodw2d0p8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/03/04/javascript中的原型链/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">javascript中的原型链</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/05/Redux/">Redux</a>
          </li>
        
          <li>
            <a href="/2018/03/04/javascript中的原型链/">javascript中的原型链</a>
          </li>
        
          <li>
            <a href="/2017/09/02/git使用/">git使用</a>
          </li>
        
          <li>
            <a href="/2017/09/01/maven/">maven</a>
          </li>
        
          <li>
            <a href="/2017/08/30/java注解/">java注解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 joker<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">分类</a>
  
</nav>
    

        <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script> -->

        <script src="/js/jquery.min.js"></script>

            
                <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
                    <script src="/fancybox/jquery.fancybox.pack.js"></script>
                        

                            <script src="/js/script.js"></script>
  </div>
</body>
</html>